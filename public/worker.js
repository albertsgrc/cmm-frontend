// Generated by CoffeeScript 1.12.4
var actions, continueIterator, debug, debugAction, debugging, evaluateDebugStatus, flagPause, iterator, memory, onmessage, output, representation, resume, vm;

importScripts('/lib/cmm/index.min.js');


/*
iterator = null

cmm.events.onstdout((output) -> setOutput output)

setAst = (s) -> postMessage({ type: "ast", value: s })
setOutput = (s) -> postMessage({ type: "output", value: s })
setErrorMsg = (s) -> postMessage({ type: "errormsg", value: s })
setDone = -> postMessage({ type: "done" })

isCIN = (value) -> value?.getType?() is 'CIN' and cmm.hooks.isInputBufferEmpty()

makeCompilation = (code) ->
    try
        ast = cmm.compile code
    catch error
        setErrorMsg "#{error.stack ? error.message ? error}"
        return

    setAst ast.toString()

    ast

runProgram = (ast, input, begin = no) ->
    try
        iterator = cmm.execute(ast, input) if begin
        loop
            it = iterator.next()
            if it.done
                setDone()
                return
            if isCIN it.value.value
                return

    catch error
        console.log(error.stack ? error.message ? error)
        setErrorMsg "#{error.stack ? error.message? error}"
 */


/*
    listen.output = ({ string }) ->
    listen.compilationError = ({ message, description }) ->
    listen.startRunning = ->
    listen.startDebugging = ->
    listen.compilationSuccessful = ({ program, ast }) ->
    listen.executionFinish = ({ status }) ->
 */

memory = new cmm.Memory;

debug = new cmm.Debugger;

vm = null;

iterator = null;

debugging = false;

flagPause = false;

output = function(string) {
  return postMessage({
    event: "output",
    data: {
      string: string
    }
  });
};

actions = {};

actions.input = function(arg) {
  var input, wasWaiting;
  input = arg.input;
  if (debugging) {
    wasWaiting = vm.isWaitingForInput();
    vm.input(input);
    console.log("Input end");
    if (vm.isWaitingForInput()) {
      return evaluateDebugStatus(vm);
    } else if (wasWaiting && (iterator != null)) {
      console.log("Continuing iterator");
      return continueIterator();
    } else {
      return console.log("Not continuing iterator");
    }
  } else {
    return resume(input);
  }
};

actions.compile = function(arg) {
  var ast, code, description, error, message, program, ref;
  code = arg.code;
  try {
    ref = cmm.compile(code), program = ref.program, ast = ref.ast;
  } catch (error1) {
    error = error1;
    message = error.getMessage(code);
    description = error.description;
    postMessage({
      event: "compilationError",
      data: {
        message: message,
        description: description
      }
    });
    return;
  }
  postMessage({
    event: "compilationSuccessful",
    data: {
      instructions: program.instructionsToString(),
      ast: ast.toString()
    }
  });
  return program;
};

resume = function(input) {
  var inputted;
  if (iterator == null) {
    throw "Not started";
  }
  if (vm != null) {
    if (input != null) {
      vm.input(input);
    }
    inputted = true;
  }
  if (!(vm != null ? vm.isWaitingForInput() : void 0)) {
    postMessage({
      event: "resumeRunning"
    });
    vm = iterator.next().value;
    if ((input != null) && !inputted) {
      vm.input(input);
    }
    while (!(vm.finished || vm.isWaitingForInput())) {
      vm = iterator.next().value;
    }
    if (vm.finished) {
      iterator.next();
      postMessage({
        event: "executionFinish",
        data: {
          status: vm.status
        }
      });
      return iterator = vm = null;
    } else {
      return postMessage({
        event: "waitingForInput"
      });
    }
  } else {
    return postMessage({
      event: "waitingForInput"
    });
  }
};

actions.run = function(arg) {
  var code, input, program;
  code = arg.code, input = arg.input;
  program = actions.compile({
    code: code
  });
  if (program != null) {
    postMessage({
      event: "startRunning"
    });
    debugging = false;
    program.attachMemory(memory);
    program.attachOutputListener(output);
    iterator = cmm.run(program);
    return resume(input);
  }
};

representation = function(value, type) {
  if (type.id === 'CHAR') {
    return "'" + value.toString() + "'";
  } else if (type.id === 'STRING') {
    return '"' + value.toString() + '"';
  } else {
    return value;
  }
};

evaluateDebugStatus = function(vm) {
  var isArray, isChar, ref, type, value, varId, variable, variables;
  if (vm.isWaitingForInput()) {
    console.log("Waiting for input");
    postMessage({
      event: "waitingForInput"
    });
  } else if (vm.finished) {
    console.log("Finished");
    postMessage({
      event: "executionFinish",
      data: {
        status: vm.status
      }
    });
    iterator = vm = null;
  } else {
    console.log("Paused");
    variables = {};
    ref = vm.instruction.visibleVariables;
    for (varId in ref) {
      variable = ref[varId];
      type = variable.type;
      isChar = type.id === 'CHAR';
      isArray = type.isArray;
      if (isArray) {
        value = type.castings.COUT(variable.memoryReference.getAddress());
      } else {
        value = type.castings.COUT(variable.memoryReference.read(memory));
      }
      variables[varId] = {
        type: type.getSymbol(),
        value: value,
        "const": variable.specifiers["const"],
        isArray: isArray,
        repr: representation(value, type),
        isChar: isChar
      };
    }
    postMessage({
      event: "paused",
      data: {
        variables: variables
      }
    });
  }
  if ((vm != null) && (vm.instruction.locations != null)) {
    return postMessage({
      event: "currentLine",
      data: {
        line: vm.instruction.locations.lines.first
      }
    });
  }
};

continueIterator = function() {
  var done, ref, ref1, vmCopy;
  postMessage({
    event: "resumeRunning"
  });
  vmCopy = vm;
  ref = iterator.next(), vm = ref.value, done = ref.done;
  while (!(done || vm.isWaitingForInput())) {
    vmCopy = vm;
    ref1 = iterator.next(), vm = ref1.value, done = ref1.done;
  }
  if (done) {
    iterator = null;
    vm = vmCopy;
  }
  return evaluateDebugStatus(vm);
};

actions.debug = function(arg) {
  var code, input, program;
  code = arg.code, input = arg.input;
  program = actions.compile({
    code: code
  });
  console.log("Debug called");
  if (program != null) {
    postMessage({
      event: "startDebugging"
    });
    debugging = true;
    program.attachMemory(memory);
    program.attachOutputListener(output);
    iterator = debug.debug(program);
    vm = iterator.next().value;
    console.log("Debug: start");
    if (input != null) {
      vm.input(input);
    }
    vm = iterator.next().value;
    console.log("Debug: stop");
    return evaluateDebugStatus(vm);
  }
};

debugAction = function(name) {
  console.log("Debug action " + name);
  if (!vm.isWaitingForInput()) {
    postMessage({
      event: "resumeRunning"
    });
    iterator = debug[name]();
    console.log("Debug action start");
    vm = iterator.next().value;
    console.log("Debug action end");
    return evaluateDebugStatus(vm);
  } else {
    return console.log("Not running debug action, waiting for input");
  }
};

actions.stepOver = function() {
  return debugAction('stepOver');
};

actions.stepInto = function() {
  return debugAction('stepInto');
};

actions.stepOut = function() {
  return debugAction('stepOut');
};

actions.stepInstruction = function() {
  return debugAction('stepInstruction');
};

actions.endOfInput = function() {
  if (vm != null) {
    vm.endOfInput();
    return resume();
  }
};

actions["continue"] = function() {
  return debugAction('continue');
};

actions.addBreakpoint = function(arg) {
  var breakpoint;
  breakpoint = arg.breakpoint;
  return debug.addBreakpoints(breakpoint);
};

actions.removeBreakpoint = function(arg) {
  var breakpoint;
  breakpoint = arg.breakpoint;
  return debug.removeBreakpoints(breakpoint);
};

actions.setVariable = function(arg) {
  var cannotParse, error, id, reference, value, variable;
  id = arg.id, value = arg.value;
  variable = vm.instruction.visibleVariables[id];
  try {
    value = variable.type.parse(value);
  } catch (error1) {
    error = error1;
    console.log(error.stack);
    cannotParse = true;
  }
  if (cannotParse) {
    return postMessage({
      event: "invalidVariableValue",
      data: {
        id: id,
        value: value
      }
    });
  } else {
    reference = variable.memoryReference;
    reference.write(memory, value);
    value = variable.type.castings.COUT(value);
    return postMessage({
      event: "variableSet",
      data: {
        id: id,
        value: value,
        repr: representation(value, variable.type)
      }
    });
  }
};

onmessage = function(e) {
  var command, data;
  data = e.data;
  command = data.command;
  if (actions[command] == null) {
    throw "invalid command " + command;
  } else {
    return actions[command](data);
  }

  /*
  switch command
      when "compile"
          makeCompilation(code, yes)
      when "input"
          cmm.hooks.setInput input
          if iterator?
              runProgram()
      when "run"
          ast = makeCompilation(code)
          if ast?
              runProgram(ast, input, yes)
      when "debug"
          console.log "debug"
      when "stop"
      when "pause"
      when "stepOver"
      when "stepInto"
      when "stepOut"
      when "endOfInput"
          cmm.hooks.endOfInput()
   */
};

//# sourceMappingURL=worker.js.map
