// Generated by CoffeeScript 1.12.4
var actions, continueIterator, debug, debugAction, debugging, evaluateDebugStatus, flagPause, iterator, memory, onmessage, output, representation, resume, sendPaused, vm;

importScripts('/lib/cmm/index.js');

memory = new cmm.Memory;

debug = new cmm.Debugger;

vm = null;

iterator = null;

debugging = false;

flagPause = false;

output = function(string) {
  return postMessage({
    event: "output",
    data: {
      string: string
    }
  });
};

actions = {};

actions.input = function(arg) {
  var input, wasWaiting;
  input = arg.input;
  if (debugging) {
    wasWaiting = vm.isWaitingForInput();
    vm.input(input);
    if (vm.isWaitingForInput()) {
      return evaluateDebugStatus(vm);
    } else if (wasWaiting && (iterator != null)) {
      return continueIterator();
    }
  } else {
    return resume(input);
  }
};

actions.compile = function(arg) {
  var ast, code, description, error, goingToRun, message, program, ref;
  code = arg.code, goingToRun = arg.goingToRun;
  try {
    ref = cmm.compile(code), program = ref.program, ast = ref.ast;
  } catch (error1) {
    error = error1;
    message = error.getMessage(code);
    description = error.description;
    postMessage({
      event: "compilationError",
      data: {
        message: message,
        description: description
      }
    });
    return;
  }
  postMessage({
    event: "compilationSuccessful",
    data: {
      instructions: program.instructionsToString(),
      ast: ast.toString(),
      goingToRun: goingToRun
    }
  });
  return program;
};

resume = function(input) {
  var inputted;
  if (iterator == null) {
    throw "Not started";
  }
  if (vm != null) {
    if (input != null) {
      vm.input(input);
    }
    inputted = true;
  }
  if (!(vm != null ? vm.isWaitingForInput() : void 0)) {
    postMessage({
      event: "resumeRunning"
    });
    vm = iterator.next().value;
    if ((input != null) && !inputted) {
      vm.input(input);
    }
    while (!(vm.finished || vm.isWaitingForInput())) {
      vm = iterator.next().value;
    }
    if (vm.finished) {
      iterator.next();
      postMessage({
        event: "executionFinish",
        data: {
          status: vm.status
        }
      });
      return iterator = vm = null;
    } else {
      return postMessage({
        event: "waitingForInput"
      });
    }
  } else {
    return postMessage({
      event: "waitingForInput"
    });
  }
};

actions.run = function(arg) {
  var code, input, program;
  code = arg.code, input = arg.input;
  program = actions.compile({
    code: code,
    goingToRun: true
  });
  if (program != null) {
    postMessage({
      event: "startRunning"
    });
    debugging = false;
    program.attachMemory(memory);
    program.attachOutputListener(output);
    iterator = cmm.run(program);
    return resume(input);
  }
};

representation = function(value, type) {
  if (type.id === 'CHAR') {
    return "'" + value.toString() + "'";
  } else if (type.id === 'STRING') {
    return '"' + value.toString() + '"';
  } else {
    return value;
  }
};

sendPaused = function() {
  var isArray, isChar, ref, type, value, varId, variable, variables;
  variables = {};
  ref = vm.instruction.visibleVariables;
  for (varId in ref) {
    variable = ref[varId];
    type = variable.type;
    isChar = type.id === 'CHAR';
    isArray = type.isArray;
    if (isArray) {
      value = type.castings.COUT(variable.memoryReference.getAddress());
    } else {
      value = type.castings.COUT(variable.memoryReference.read(memory));
    }
    variables[varId] = {
      type: type.getSymbol(),
      value: value,
      "const": variable.specifiers["const"],
      isArray: isArray,
      repr: representation(value, type),
      isChar: isChar
    };
  }
  return postMessage({
    event: "paused",
    data: {
      variables: variables
    }
  });
};

evaluateDebugStatus = function() {
  if (!vm.finished && vm.instruction.breakpoint) {
    sendPaused();
  } else if (vm.isWaitingForInput()) {
    postMessage({
      event: "waitingForInput"
    });
  } else if (vm.finished) {
    postMessage({
      event: "executionFinish",
      data: {
        status: vm.status
      }
    });
    iterator = vm = null;
  } else {
    sendPaused();
  }
  if ((vm != null ? vm.instruction.locations : void 0) != null) {
    return postMessage({
      event: "currentLine",
      data: {
        line: vm.instruction.locations.lines.first
      }
    });
  }
};

continueIterator = function() {
  var done, ref, ref1, vmCopy;
  postMessage({
    event: "resumeRunning"
  });
  vmCopy = vm;
  ref = iterator.next(), vm = ref.value, done = ref.done;
  while (!(done || vm.isWaitingForInput())) {
    vmCopy = vm;
    ref1 = iterator.next(), vm = ref1.value, done = ref1.done;
  }
  if (done) {
    iterator = null;
    vm = vmCopy;
  }
  return evaluateDebugStatus(vm);
};

actions.debug = function(arg) {
  var code, input, program;
  code = arg.code, input = arg.input;
  program = actions.compile({
    code: code,
    goingToRun: true
  });
  if (program != null) {
    postMessage({
      event: "startDebugging"
    });
    debugging = true;
    program.attachMemory(memory);
    program.attachOutputListener(output);
    iterator = debug.debug(program);
    vm = iterator.next().value;
    if (input != null) {
      vm.input(input);
    }
    vm = iterator.next().value;
    return evaluateDebugStatus(vm);
  }
};

debugAction = function(name) {
  if (vm.isWaitingForInput()) {
    postMessage({
      event: "waitingForInput"
    });
    return iterator = debug[name]();
  } else {
    postMessage({
      event: "resumeRunning"
    });
    iterator = debug[name]();
    vm = iterator.next().value;
    return evaluateDebugStatus(vm);
  }
};

actions.stepOver = function() {
  return debugAction('stepOver');
};

actions.stepInto = function() {
  return debugAction('stepInto');
};

actions.stepOut = function() {
  return debugAction('stepOut');
};

actions.stepInstruction = function() {
  return debugAction('stepInstruction');
};

actions.endOfInput = function() {
  if (vm != null) {
    vm.endOfInput();
    return resume();
  }
};

actions["continue"] = function() {
  return debugAction('continue');
};

actions.addBreakpoint = function(arg) {
  var breakpoint;
  breakpoint = arg.breakpoint;
  return debug.addBreakpoints(breakpoint);
};

actions.removeBreakpoint = function(arg) {
  var breakpoint;
  breakpoint = arg.breakpoint;
  return debug.removeBreakpoints(breakpoint);
};

actions.setVariable = function(arg) {
  var cannotParse, error, id, reference, value, variable;
  id = arg.id, value = arg.value;
  variable = vm.instruction.visibleVariables[id];
  try {
    value = variable.type.parse(value);
  } catch (error1) {
    error = error1;
    cannotParse = true;
  }
  if (cannotParse) {
    return postMessage({
      event: "invalidVariableValue",
      data: {
        id: id,
        value: value
      }
    });
  } else {
    reference = variable.memoryReference;
    reference.write(memory, value);
    value = variable.type.castings.COUT(value);
    return postMessage({
      event: "variableSet",
      data: {
        id: id,
        value: value,
        repr: representation(value, variable.type)
      }
    });
  }
};

onmessage = function(e) {
  var command, data;
  data = e.data;
  command = data.command;
  if (actions[command] == null) {
    throw "invalid command " + command;
  } else {
    return actions[command](data);
  }
};
